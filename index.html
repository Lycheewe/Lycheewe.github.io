<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="杰瑞李">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="杰瑞李">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="杰瑞李">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>杰瑞李</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">杰瑞李</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/06/【解释】拼多多为什么会成功/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杰瑞李">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/06/【解释】拼多多为什么会成功/" itemprop="url">【解释】拼多多为什么会成功</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-06T17:40:15+08:00">
                2019-11-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>拼多多近期的领现金裂变从传播上来看非常成功，ROI没有数据可算，但拉新成本肉眼可见的低，想起来拼多多刚上市时的分析。</p>
<p>从商业产品的角度来看，现阶段供需市场环境同时满足量大与分散两个先决特点，展开来讲，阿里为做消费升级，提高arpu值，战略放弃了大量的中低端供应商，过剩产能得不到分销，造成库存堆积所带来的高昂成本；</p>
<p>同时14年春节微信红包雨大大扩展了移动支付的覆盖面积，微信钱包都有了零钱，16、17年智能手机的出货量剧增，需求侧规模化购买条件得到满足。把消费者需求行为的确定性产品化的成本大幅降低，可以说拼多多平台在我们习以为常的表象背后，借势而生。</p>
<p>如今假货的泛滥不论是“消费降级”的意外还是“劣币驱逐良币”的必然，都与黄铮所谓 用需求流通侧的半“计划经济”来推动实现供给侧的半”市场经济“的最初理念相悖，或许也不能用一家三年上市的“成功”作为创始人“创造社会价值”希冀的归宿。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/06/【解释】A-B测试中假设检验的应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杰瑞李">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/06/【解释】A-B测试中假设检验的应用/" itemprop="url">【解释】A/B测试中假设检验的应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-06T14:40:54+08:00">
                2019-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/解释/" itemprop="url" rel="index">
                    <span itemprop="name">解释</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>A/B测试的概念相信大家都耳熟能详，头条系app发展迅速后，这个概念更是成了互联网增长圈子里的圣经，仿佛什么功能上线之前都能进行A/B测试来验证效果。但是A/B测试得到的结果具体应该怎么评估呢，A版本和B版本所得到的数据效果差异该怎么评判？</p>
<p>假设随机抽取了大量的两组用户，测试新功能，希望能提高用户平均购买金额；保证样本量和测试时长足够，发现新功能版本有提升1%，怎样确定这个结果是可信的？  </p>
<p>这个问题可以通用描述成 旧版本所得到的指标均值为 <script type="math/tex">\bar{x}</script> ，新版本所得到的指标均值为 <script type="math/tex">\bar{y}</script>，<script type="math/tex">\bar{y}</script> 的数值表现好于 <script type="math/tex">\bar{x}</script>，怎样评估新版本有效？</p>
<p>先明确一个问题，什么是假设检验呢？假设检验是通过样本平均数推论总体平均数的统计方法。，那么能够建立样本平均数与总体平均数的关系，就能通过研究样本得到对总体（所有用户）的结论。它涉及多个统计基础，比如：z分数（标准正态分布）、概率及分布、样本平均数的分布。</p>
<p>我们可以利用双样本 <script type="math/tex">t</script> 检验，原假设 <script type="math/tex">H0</script> 为新版本指标均值维持不变，取 <script type="math/tex">\alpha</script> =0.05，然后 找相关自由度的 <script type="math/tex">t</script> 分布的95%分位数，也就是看<script type="math/tex">\bar{y}</script> 是否在<script type="math/tex">x</script> 的 <script type="math/tex">t</script> 分布95%置信区间内，如果不在这个置信区间里，则说明 (1) 我们得到了一个概率极小的实验结果 或者 (2) 零假设是错误的 ，所以就可以显著拒绝原假设，新版本有效。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/03/【复盘】kaggle练习之titanic生存预测/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杰瑞李">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/03/【复盘】kaggle练习之titanic生存预测/" itemprop="url">【复盘】kaggle练习之titanic生存预测</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-03T19:48:00+08:00">
                2019-11-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前学习数据挖掘竞赛，跟着做了kaggle上的titanic练习赛，复盘下过程与思考。</p>
<h2 id="数据总览"><a href="#数据总览" class="headerlink" title="数据总览"></a>数据总览</h2><p>info函数可看出Age、Cabin、Embarked、Fare几个特征存在缺失值，缺失值的处理方法一般有以下几种：</p>
<p>（1）如果数据集很多，但有很少的缺失值，可以删掉带缺失值的行；</p>
<p>（2）如果该属性相对学习来说不是很重要，可以对缺失值赋均值或者众数。比如在哪儿上船Embarked这一属性（共有三个上船地点），缺失俩值，可以用众数赋值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data.Embarked[train_data.Embarked.isnull()] = train_data.Embarked.dropna().mode().values</span><br></pre></td></tr></table></figure>
<p>（3）对于标称属性，可以赋一个代表缺失的值，比如‘U0’。因为缺失本身也可能代表着一些隐含信息。比如船舱号Cabin这一属性，缺失可能代表并没有船舱</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#replace missing value with U0</span></span><br><span class="line">train_data[<span class="string">'Cabin'</span>] = train_data.Cabin.fillna(<span class="string">'U0'</span>) <span class="comment"># train_data.Cabin[train_data.Cabin.isnull()]='U0'</span></span><br></pre></td></tr></table></figure>
<p>（4）使用回归 随机森林等模型来预测缺失属性的值。因为Age在该数据集里是一个相当重要的特征（先对Age进行分析即可得知），所以保证一定的缺失值填充准确率是非常重要的，对结果也会产生较大影响。一般情况下，会使用数据完整的条目作为模型的训练集，以此来预测缺失值。对于当前的这个数据，可以使用随机森林来预测也可以使用线性回归预测。这里使用随机森林预测模型，选取数据集中的数值属性作为特征（因为sklearn的模型只能处理数值属性，所以这里先仅选取数值特征，但在实际的应用中需要将非数值特征转换为数值特征）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/03/【复盘】2018华为软件精英挑战赛回想/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杰瑞李">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/03/【复盘】2018华为软件精英挑战赛回想/" itemprop="url">【复盘】2018华为软件精英挑战赛回想</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-03T16:14:12+08:00">
                2019-11-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>复盘一下之前参加的华为软挑，算是拾起很久没接触过的数学模型知识。</p>
<p>【赛题回顾】<br><strong>背景：</strong></p>
<p>云平台为了满足不同租户的需求,提供了一种可随时自助获取、可弹性伸缩的云服务器,即弹性云服务器(Elastic Cloud Server,ECS)。为容纳更多的租户请求、并尽可能提高资源利用率、降低成本,自动化、智能化的资源调度管理系统非常关键。</p>
<p>由于租户对ECS实例(虚拟机,VM)请求的行为具有一定规律,可以通过对历史ECS实例请求的分析,预测到未来一段时间的ECS实例请求,然后对预测的请求分配资源(如图1所示),这样可以找到一个接近最优的分配策略,实现资源最大化利用,同时也能参考预测的结果制定云数据中心的建设计划。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8kx9mjr91j30fd0520t8.jpg" alt></p>
<p>物理服务器:<br>云数据中心通常由大规模的物理服务器集群所组成,通过虚拟化技术,可以对每个物理节点的资源(如CPU、内存、硬盘等)进行隔离,使得每台物理机上可以同时容纳多个虚拟机,这些虚拟机即共享该物理服务器上的所有资源。为了保证每台虚拟机的运行性能,通常物理资源不能“超分”,即每台物理服务器上所有虚拟机的虚拟资源总量不能超过其物理资源总量。这里假设物理服务器只有一种规格大小。</p>
<p>虚拟机规格:<br>云平台通常预先定义了各种类型虚拟机的规格(flavor),便于租户选择购买。例如,如果租户对计算要求低,而内存要求相对高,可以选择4个vCPU、16GB内存的配置。由于不考虑物理资源的“超分”,虚拟机的资源占用可与物理资源进行一比一的映射。当然,不同规格的虚拟机有不同的性能,价格也不一。</p>
<p>资源维度:<br>如上述,虚拟机正常工作需要多个维度的资源同时配合,如CPU、内存、硬盘、网络等等,每种资源都可能成为瓶颈,并且每种资源分配不合理都可能产生碎片。这里假设只需要考虑单个维度资源的使用,即尽可能最大化每台物理服务器的CPU或者内存(Mem)的利用率,但在考虑某个维度资源优化的同时,要保证其他资源不能超分。</p>
<p>历史请求数据:<br>租户在云平台上每申请一台虚拟机都会在后台的数据库产生一条数据,每条数据包含了虚拟机的ID、虚拟机的规格大小以及创建时间等。如果我们可以获取到云平台在过去一段时间的所有虚拟机请求数据,通过训练这些数据特征,可以预测下一个时间段可能到来的虚拟机请求分布。</p>
<p>比赛程序内容:<br>请你设计一个程序能够精确预测未来某个时间段内的虚拟机的请求情况,并寻找最佳的资源分配方案:对输入的虚拟机历史请求数据进行建模分析以及训练,确定系数给出预测模型,然后对给定预测时间段内不同规格的虚拟机数量进行预测,最后根据预测结果把虚拟机部署到物理服务器上,使得服务器的资源利用率最大化。</p>
<p>比赛胜负规则<br>比较参赛者程序输出的预测结果的精度以及部署的资源利用率的乘积,得分较大者胜出。如果出现得分相同的情况,则比较程序运行时间,时间短者胜出。若运行时间也相同,则根据提交时间先后来区分排名。如输出结果不满足约束条件,得分为零。 (备注:资源利用率只需要考虑单个维度,如CPU或内存的利用率)</p>
<p>【解决方案】</p>
<p>简单来讲，赛题问题可以分为两部分，1.根据每个flavor的历史请求数据，建立预测模型来对未来一段时间（一周至两周）的订单数据各flavor总量进行预测  2.根据预测得到的flavor请求数，编写放置分配算法。</p>
<p>本次比赛，我主要参与了预测阶段的工作，包含数据预处理以及预测模型的构建。</p>
<p><strong>平均值大法</strong>：</p>
<p>最开始运用直接求平均值来作为参照预测的方法，按照训练数据时间长度（一个月）和待预测时间段（一周）的比例，以及训练数据中各种虚拟机用量的统计数据，来预测未来时间段的虚拟机用量。这种方法简单粗暴，适合较为平稳的数据集，除去噪声影响，效果应该不算差。但是根据线上线下的测试结果，预测数据偏低，虚拟机的用量随时间呈现一个增长的趋势，这时可以设定修正系数，如α = 1.2，来加入趋势增长的信息。</p>
<p><strong>滑动平均+线性回归</strong>：</p>
<p>直接运用平均的方法丢失了较多信息，结果并不如人意，考虑改用滑动平均的方法，根据待预测目标的时间长度（一周），对训练时间内各种虚拟机的用量序列进行滑动求和，即统计计算连续一周内的虚拟机用量。这里涉及到一个步长的概念，滑动步长为1，即滑动一天求和一次；还有滑动一周求和一次等等，比赛中我们试了不少步长，发现步长为一周7天的效果相对较好。求得滑动求和（平均）序列后，在此基础上做线性回归来预测未来flavor数量。</p>
<p><strong>加权平均</strong>：</p>
<p>借鉴指数平滑和滑动平均的一种模型，以滑动求和序列为基础，做加权平均。时间序列预测的一个特点我认为是与待预测时间越接近的历史数据越为重要，考虑利用权重分配来进行预测</p>
<script type="math/tex; mode=display">
X_{t}=\alpha X_{t-1}+\alpha(1-\alpha) X_{t-2}+\alpha(1-\alpha)^{2} X_{t-3}+\cdots+\alpha(1-\alpha)^{n-1} X_{t-n}</script><p>这个方法有一些自回归（Auto-Regression）的意思。当n趋于无穷时，系数的求和为1。这里引入了一个参数<script type="math/tex">\alpha</script>，所以可以进行一些调参，但是还是因为时间问题，尝试的机会不多了。队友随便定了一个0.6，效果比上面的方法都要好很多。</p>
<h3 id="滑动平均法的优缺点"><a href="#滑动平均法的优缺点" class="headerlink" title="滑动平均法的优缺点"></a>滑动平均法的优缺点</h3><p>使用移动平均法进行预测能平滑掉需求的突然波动对预测结果的影响。但移动平均法运用时也存在着如下问题：</p>
<p>1、 加大移动平均法的期数（即加大n值）会使平滑波动效果更好，但会使预测值对数据实际变动更不敏感；</p>
<p>2、 移动平均值并不能总是很好地反映出趋势。由于是平均值，预测值总是停留在过去的水平上而无法预计会导致将来更高或更低的波动；</p>
<p>3、 移动平均法要由大量的过去数据的记录。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/30/【insights】买书与运动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杰瑞李">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/30/【insights】买书与运动/" itemprop="url">【insights】买书与运动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-30T16:24:36+08:00">
                2019-10-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>买书如山倒，读书如抽丝。人对于读书、学习这种需要自律、需要坚持的行为往往会高估短期执行力，低估坚持长期带来的改变。</p>
<p>运动服装和图书一样，健身前买齐一套高档健身衣，办健身年卡。健身房与运动服饰品牌也是利用人一时间的热情，短暂的积极性带来的低决策成本实现商品、服务的售卖。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/29/【笔记】k8s核心概念总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杰瑞李">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/29/【笔记】k8s核心概念总结/" itemprop="url">【笔记】k8s核心概念总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-29T16:01:42+08:00">
                2019-10-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先了解下六层抽象及相应的组成部分，然后再看下七个关键的 K8s API 对象。</p>
<p>K8s 的 6 个抽象层</p>
<p>我们假设有一个持续运行且不需要存储状态的应用。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f530v2fzj30a70gz74m.jpg" alt></p>
<p>下面是 K8s 的6层抽象，级别由高到低排列：</p>
<ul>
<li>Deployment</li>
<li>ReplicaSet</li>
<li>Pod</li>
<li>Node Cluster</li>
<li>Node Processes</li>
<li>Docker Container</li>
</ul>
<p>Deployment 负责创建及管理 ReplicaSet，ReplicaSet 负责创建及管理 Pod，Pod 运行在 Node 中，Node 中有容器运行时，可以运行放入 Docker 镜像中的应用代码，听起来就像爱尔兰民谣歌曲 “The Rattlin’Bog”。</p>
<p>下面是从 Worker Node 中分化的示意图，可以让我们深入了解下期内部结构。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f539gnc1j30ji0gct9p.jpg" alt></p>
<p>蓝色阴影部分是 K8s 高层次的抽象层，绿色部分代表 Node 层及 Node 子进程，这一点只需要了解，后面可能不会讲到。</p>
<p>需要注意的是 K8s 实例通常会在单个 Node 中运行多个 Pod。</p>
<p>Docker 容器包含应用代码。</p>
<p>下面我们分别来看下6个抽象层，从最高层开始。</p>
<p><strong>Deployment</strong></p>
<p>如果你想持续运行一个无状态的应用，比如 HTTP 服务器，那么你需要 Deployment，Deployment 允许你在无需停机的状态下更新应用，并在 Pod 宕掉时根据策略重启 Pod。</p>
<p>你可以通过命令行或者配置文件创建 Deployment，我会在后续的文章中展示两种方法，请保持持续关注。</p>
<p><strong>ReplicaSet</strong></p>
<p>Deployment 会创建 ReplicaSet 来保障你的应用所需 Pod 的数量，ReplicaSet 会基于 Deployment 中的触发器自动创建及伸缩 Pod 数量。</p>
<p>Replication Controller 也支持和 ReplicaSet 相同的功能，但前者已经是 old school 了，后者才是2019年管理复制 Pod 的明智方式。</p>
<p><strong>Pod</strong></p>
<p>Pod 是 K8s 的基础构建模块，一个 Pod 包含一组一个或多个容器。通常每个 Pod 包含一个容器。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f53zq77dj30hs0bvdg5.jpg" alt></p>
<p>Pod 会处理 Volume、Secret 以及容器的相关配置。</p>
<p>Pod 不是持久的，会在宕掉时自动重启。</p>
<p>当应用需要水平扩展时，ReplicationSet 会复制 Pod。</p>
<p>Pod 活在 Worker Node 中。</p>
<center>集群层面</center>

<p><strong>集群</strong></p>
<p>K8s 集群由 Master 集群和 Worker Node 组成。</p>
<p>下面是集群的示意图，图片重点展示了多个 Pod 是如何运行正在 Worker Node 中以及 Master 如何治理 Worker Node 的。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f5522gu3j30hg0got9y.jpg" alt></p>
<p><strong>Worker Node</strong></p>
<p>Worker Node 可以简称为 Node。Node 是机器的抽象，物理机或者虚拟机，可以把 Node 看作计算机服务器。</p>
<p>一个或多个 Pod 运行在一个 Worker Node 中。</p>
<p>一个 Pod 绝不会拆分到不同的 Node 中，Pod 中的内容总是位于同一个 Node 并一起调度。</p>
<p>那么谁来指挥 Worker Node 该做什么呢？Master 集群。</p>
<p><strong>Cluster Master</strong></p>
<p>Master 集群有很多好玩的别名，如 Master 节点、Kubernetes Master、集群控制面板、控制面板或者直接叫 Master，但无论怎么叫，它的作用是治理 Worker Node。</p>
<p>Master 做出调度决策，响应事件，实现更改，并监视集群。</p>
<p>Master 和 Worker Node 都包含子进程组件。</p>
<center>Node 进程</center>

<p><strong>Master 组件</strong></p>
<p>Master 组件包含 API server（即 kube-apiserver）、Scheduler（即 kube-scheduler）、kube-controller-manager 及 cloud-controller manager。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f56bmoe6j30h30awmxz.jpg" alt></p>
<p>下面我们简要看下各个组件。</p>
<p>API Server——暴露 K8s API，是 K8s 控制的前端，即 kube-apiserver，可以当做是 hub。</p>
<p>etcd——用于集群状态数据的分布式键值存储。</p>
<p>Scheduler——为新 Pod 选择 Node，即 kube-scheduler，可以想象成匹配器，参考这里[2]。</p>
<p>kube-controller-manager——运行控制器来处理集群后台任务的进程，可当做集群控制器。</p>
<p>cloud-controller-manager——运行控制器与云供应商交互，可以当做云接口。</p>
<p><strong>Worker Node 组件</strong></p>
<p>Worker Node 的组件包括 kubelet、kube-proxy 及 容器运行时。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f56tkqx1j30fq0ag3z5.jpg" alt></p>
<p>kubelet——负责 Worker Node 的一切事务，与 Master 的 API server 通信。</p>
<p>kube-proxy——连接正确 Pod 的路由，也扮演跨 Pod 服务负载均衡的角色。</p>
<p>容器运行时——下载镜像，运行容器，例如：Docker 就是一个容器运行时。</p>
<p>让我们深入到最后一层，看看这些容器运行时中在运行什么。</p>
<center>Docker 容器层面</center>

<p>如果你想使用 K8s 运行应用，应用需要在容器中。Docker 是目前为止最为常用的容器平台，我们假设你在使用 Docker。</p>
<p>在创建 Deployment 时，需要确定 Pod 应该使用哪个 Docker 镜像，容器运行时（runtime）会下载镜像并创建容器。</p>
<p>K8s 不会直接创建容器，它会创建包含容器的 Pod。Pod 中的容器会共享配置资源，如 Volume 存储。</p>
<p>管理和运行 Pod 的高级别 K8s API 资源有5个: Deployment，StatefulSet， DaemonSet，Job 和 CronJob。这些对象负责管理和运行 Pod，来创建和运行容器。</p>
<p>下面让我们看看这些创建和管理连续流程的控制器。</p>
<center>ReplicaSets，StatefulSets 及 DaemonSets</center>

<p>正如你所了解到的，ReplicaSet 创建并管理 Pod。如果由于 Node 出错，导致 Pod 关闭，ReplicaSet 会自动在另外的 Node 中替换 Pod。所以应该通过 Deployment 来创建 ReplicaSet，而不是直接创建，因为通过 Deployment 可以更加轻松地更新应用。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f58iopqcj30ig0ad3zf.jpg" alt></p>
<p>应用有时需要保存状态（state）信息，你可以将状态认为是当前用户与应用交互的状态。所以在电子游戏中，它是用户角色在某个时间点上的所有的唯一形态。</p>
<p>例如，在最初的《超级马里奥兄弟》游戏中，状态将包含用户游戏的所有相关方面：什么级别，该级别中的位置，大或小，火球或没有火球，多少硬币，多少点数，以及多少生命。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f58vpdi8j30u00mfjv9.jpg" alt></p>
<p>如果 APP 需要追踪状态，该怎么办呢？使用 StatefulSet。</p>
<p><strong>StatefulSet</strong></p>
<p>与 ReplicaSet 一样，StatefulSet 根据容器规范管理一组 Pod 的部署和伸缩。与 Deployment 不同，StatefulSet 的 Pod 是不可互换的。每个 Pod 都有一个唯一的、持久的标识符，在任何重新调度期间，控制器都要维护这个标识符。StatefulSet 用于持久的、有状态的后端，如数据库。</p>
<p>Pod 的状态信息保存在与 StatefulSet 关联的 Volume 中。我们稍后会讲到 Volume。</p>
<p><strong>DaemonSet</strong></p>
<p>DaemonSet 用于处理连续的过程，在每个 Node 上运行一个 Pod，每个自动被放入集群的 Node 会通过 DaemonSet 启动 Pod。DaemonSet 对后台运行的任务(如监控和日志收集)非常有用。</p>
<p>StatefulSet 和 DaemonSet 不受 Deployment 控制，虽然两者与 ReplicaSet 位于同级别的抽象层，在当前 API 中没有针对它们更高层级的抽象层了。</p>
<p>下面我们来看下 Job 和 CronJob。</p>
<center>Jobs and CronJobs</center> 

<p><strong>Job</strong></p>
<p>Job 是 Pod 批处理的 supervisor。Job 创建 Pod，并通过跟踪成功完成任务的 Pod 数量来确保任务的执行。与 ReplicaSet 不同，一旦容器内的任务成功完成，容器就不再重新启动。当运行一次性任务时，可以使用 Job。</p>
<p><strong>CronJob</strong></p>
<p>如果你想定期在特定时间（如每个小时，每天或者每月）运行 Job，可以创建一个 CronJob，CronJob 和 Job 类似，但它是在固定的时间间隔，定时重复执行。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f59o1azkj30hs0bumz6.jpg" alt></p>
<p>你经常需要创建一个服务来提供对临时 Pod 的一致访问。</p>
<p><strong>Service</strong></p>
<p>K8s 服务为一组 Pod 创建一个访问点。服务提供一致的 IP 地址和端口来访问底层 Pod。外部用户和内部 Pod 都使用服务与其他 Pod 通信。</p>
<p>服务种类繁多。与 K8s 建立网络是一个值得参考的主题。幸运的是，Sandeep Dinesh 有一个很好的参考案例[3]。</p>
<p>下面我们来看下使用 Volume 和 PersistentVolume 存储数据。</p>
<center>Volumes，PersistentVolumes 及 PersistentVolume Claims</center>

<p><strong>Volume</strong></p>
<p>Volume 是可以存放数据的目录，是 Pod 的组成部分，不独立于 Pod 存在。基于 Pod 规范创建 Volume，并且 Volume 不能单独删除。</p>
<p>Pod 中的容器都可以访问 Volume，每个想访问 Volume 的容器必须单独挂载它。</p>
<p>K8s Volume 的生命周期比任何容器的生命周期都长，当外围的 Pod 死掉后，Volume 也会死掉。但某些 Volume 类型的文件会继续存在于本地或者云端，即使在 Volume 消失之后。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f5ajv9xmj30hs0bu40l.jpg" alt></p>
<p>K8s Volume 比 Docker volume 更具实用性，K8s Volume 可以访问本地磁盘存储、内存或者云端存储，Pod 可以同时组合使用。</p>
<p>K8s Volume 类型包含空目录、工作节点的文件系统以及特定云服务商存储。例如，awsEleasticBlockStore 和 gcePersistentDisk 是提供长期存储的特定服务商。更多内容可参考文档[4]。</p>
<p><strong>PersistentVolumes 和 PersistentVolumeClaims</strong></p>
<p>为了更好地抽象出基础设施的细节，K8s 开发了 persistentvolume 和PersistentVolumeClaim。不幸的是，名字有点误导人，因为普通的 Volume 也可以持久存储。</p>
<p>与独立使用 Volume 相比， PersisententVolume（PV）和 PersisentVolumeClaim（PVC）增加了复杂性，但 PV 对于大型项目的存储资源管理很有用处。</p>
<p>使用 PV 时，用户实际上最终使用的还是 Volume，但需要做两步操作。</p>
<ol>
<li>PersistentVolume 由 集群 admin 提供（或者动态提供）。</li>
<li>对于 Pod 所需的存储，集群用户创建一个 PersistentVolumeClaim 清单， 来指定所需的存储空间和存储类型。然后 K8s 查找并保留所需的存储。</li>
</ol>
<p>然后用户创建一个Pod， Pod 使用了 PVC 的 Volume。</p>
<p>PersistentVolume 具有独立于 Pod 的生命周期，事实上，Pod 甚至都不知道 PV，只知道 PVC。</p>
<p>PVC 消耗 PV 资源，类似 Pod 消耗 Node 资源。</p>
<center>总结</center>

<p>我希望这篇对 K8s 概念的介绍对你有用，如果帮到了你，希望你可以在社交平台上分享，以便别人也可以读到。</p>
<p>下面我们总结一些上述讲到的 K8s 概念，Deployment 的六层抽象：</p>
<ul>
<li><p>Deployment：管理 ReplicaSet，用于持久的，无状态的应用（如 HTTP 服务器）</p>
</li>
<li><p>ReplicaSet：创建及管理 Pod</p>
</li>
<li><p>Pod：K8s 基本单元</p>
</li>
<li><p>Node 集群：Worker Node Master集群</p>
</li>
<li><ul>
<li>Worker Node：运行 Pod 的机器</li>
<li>Master 集群：治理 worker node</li>
</ul>
</li>
<li><p>Node 进程</p>
<p>Master 组件：</p>
</li>
<li><ul>
<li>API server：hub</li>
<li>etcd：集群信息</li>
<li>scheduler：匹配器</li>
<li>kube-controller-manager：集群控制器</li>
<li>cloud-controller-manager：云端接口</li>
</ul>
</li>
<li><p>Worker Node 组件：</p>
</li>
<li><ul>
<li>kubelet：Worker Node 大脑</li>
<li>kube-proxy：交通警察</li>
<li>container-runtime：Docker</li>
</ul>
</li>
<li></li>
<li><p>Docker Container：app 代码运行的地方</p>
</li>
</ul>
<p>下面是另外 7 个需要知道的高级别 K8s API 对象：</p>
<ul>
<li>StatefulSet：与 ReplicaSet 类似，用于处理有状态的进程。</li>
<li>DaemonSet：每个 Node 中自动化的 Pod，联想下监控。</li>
<li>Job：运行容器以完成操作，批处理。</li>
<li>CronJob：重复的 Job，联想下定时任务。</li>
<li>Service：Pod 的访问入口。</li>
<li>Volume：存储数据，联想硬盘。</li>
<li>PersistentVolume，PersistentVolumeClaim：分配存储的系统。</li>
</ul>
<p>理解 k8s 需要理解许多抽象概念。不要指望第一次就能记住。查看下面的一些资源来构建你的心智模型。</p>
<center>资源</center>

<p>下面的资源可以加深你所学到知识。</p>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&amp;mid=2649696224&amp;idx=1&amp;sn=d80a082157b8c9bea33e2c1fbffe4108&amp;chksm=88931883bfe4919521b701051519d3ba72690bc381e47b3c12d60620c293d38ed22cf2a597ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">来自 Google 的漫画版核心概念</a></li>
<li>另外一个来自 Daniel Sanche 的比较好的 K8s 核心概念概览[5]</li>
<li>查看 Nigel Poulton 的 The Kubernetes Book[6]</li>
</ul>
<p>相关链接：</p>
<ol>
<li><p><a href="https://towardsdatascience.com/learn-enough-docker-to-be-useful-b7ba70caeb4b" target="_blank" rel="noopener">https://towardsdatascience.com/learn-enough-docker-to-be-useful-b7ba70caeb4b</a></p>
</li>
<li><p><a href="https://medium.com/@dominik.tornow/the-kubernetes-scheduler-cd429abac02f" target="_blank" rel="noopener">https://medium.com/@dominik.tornow/the-kubernetes-scheduler-cd429abac02f</a></p>
</li>
<li><p><a href="https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0" target="_blank" rel="noopener">https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0</a></p>
</li>
<li><p><a href="https://kubernetes.io/docs/concepts/storage/volumes/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/storage/volumes/</a></p>
</li>
<li><p><a href="https://medium.com/google-cloud/kubernetes-101-pods-nodes-containers-and-clusters-c1509e409e16" target="_blank" rel="noopener">https://medium.com/google-cloud/kubernetes-101-pods-nodes-containers-and-clusters-c1509e409e16</a></p>
</li>
<li><p><a href="https://www.amazon.com/Kubernetes-Book-Version-November-2018-ebook-dp-B072TS9ZQZ/dp/B072TS9ZQZ/ref=mt_kindle?_encoding=UTF8" target="_blank" rel="noopener">https://www.amazon.com/Kubernetes-Book-Version-November-2018-ebook-dp-B072TS9ZQZ/dp/B072TS9ZQZ/ref=mt_kindle?_encoding=UTF8</a></p>
</li>
</ol>
<p>原文链接：<a href="https://towardsdatascience.com/key-kubernetes-concepts-62939f4bc08e" target="_blank" rel="noopener">https://towardsdatascience.com/key-kubernetes-concepts-62939f4bc08e</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/23/【泛PM】云产品与C端产品设计差异/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杰瑞李">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/23/【泛PM】云产品与C端产品设计差异/" itemprop="url">【泛PM】云产品与C端产品设计差异</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-23T19:44:30+08:00">
                2019-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在进行云平台产品设计时，一个困惑是产品功能无法完全地通过产品设计来展现给用户，简单说就是云产品、复杂B端产品通常会涉及到专业的业务知识。这里的业务知识是指广义的业务，比如为开发者服务的云平台，通常涉及到许多“晦涩”的技术背景知识，例如开源框架的使用。这时的产品信息架构中，便会不可避免出现小白（指我）无法一眼理解的模块设计，例如云产品中的集群、部署组、可用区等概念，以及正常用户产品认为是不完美的使用地图和交互。</p>
<p>一个解决方案是牺牲页面的简洁，添加各种引导文案及标识来被动加快用户适应的进度；另一个方案是用户文档，产出更高要求的用户文档来主动指导用户更快地了解产品的使用路径，减少试错成本。</p>
<p>当然并不是说产品设计不重要，而是在特定场景下，目标用户通常是有一定的学习力，用户文档会是更好的方式实现“优化”，与其在添加太多跳转与引导文字，既增加了信息架构的复杂度，又增加了操作路径；不如利用文档来辅助产品设计</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/21/【复盘】搜索提升变现效率case/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杰瑞李">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/21/【复盘】搜索提升变现效率case/" itemprop="url">【复盘】搜索提升变现效率case</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-21T19:02:57+08:00">
                2019-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在此回想和记录下第一次实习时改进搜索策略，提升广告变现效率的方案。</p>
<p>2345手机助手一直是应用宝流量联盟比较重要的Top渠道方，日均能带来10w+流水，方案背景是针对2345搜索场景变现效率不足情况，通过调整搜索召回策略及改进广告展示样式来提高pvr广告展现率，同时提升返回的商业化结果转化率。</p>
<p>首先对合作渠道方提供的单月Query数据进行数据分析，得到数据集的描述统计变量，query词数量总共18w，产生总QV日均200w，其中Top1000 query个数所占比约69%，体现query分布的长尾效应。Top100 query产生的QV中，54%来自模糊词，eg.「一」「我」「w」「小」等，前缀词&amp;精准词匹配到的结果以非广告结果为主，占比约71.5%。</p>
<p>以上数据表明，模糊词query占query总数绝大部分，大量query下无商业化曝光，优化策略的主要方向是通过召回热搜、专题等内容来提升广告的曝光量，提升pvr；同时对前缀词和精准词的返回结果，拉取强素材广告，如普通卡片、聚合卡片、三图卡片、专题卡片等样式，提升曝光率并吸引用户下载；进行自然精准结果的打压，商业精准结果强化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/21/【Grow】三个月云pm的一点思考/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杰瑞李">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/21/【Grow】三个月云pm的一点思考/" itemprop="url">【Grow】三个月云pm的一点思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-21T00:03:47+08:00">
                2019-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>入职百度三个月了，记录下自己工作的思考和感受。</p>
<p>作为非科班出身的云计算小白，之前对于云计算的认知仅仅停留在租VPS搭梯子探索世界的层面，虽然入职前看了一些云和To B的行业分析文，但其实都只是城外宏观上的一瞥，真正的业务还需要躬身实践才知深浅。</p>
<p>来了之后主要参与的是容器、k8s和微服务相关的工作，乍一听极为懵逼，所有的汉字都认得，组合到一起就仿佛天书。诚然，这些概念都是较为偏向技术架构层面的知识，本文不谈这些技术的具体细节，说实话目前的我还无法将这些术语讲的透彻，主要谈谈作为pm的一些思考。</p>
<p>有句话说的好，云上的一切产品其实都是API。API，即应用程序编程接口，在我的理解，API就是将某一模块封装起来提供让外界能够进行调用的一种方式，就好像乐高玩具所规定的拼接部位。云上的产品，不同产品线之间，充斥着API之间的调用。因为许多产品的诞生都是基于其他众多产品的基础上，自然而然地生长出来，就如同云☁️这个概念所传达的含义，IaaS层生长出PaaS，再生长出SaaS。拿云原生这个概念来说，应用程序作为最上层不断生长的植物，根一定扎在底层的服务器BCC土壤中，而磁盘CDS、网络VPC、公网EIP等等，这些都可以看做是土壤的养分以及土壤与空气接触的表面积。企业做应用程序，绝不是仅仅种植一棵植物，而是一片农田或一片森林，这时植物间的灌溉与照料工作，就需要以集群的维度来进行处理，而容器Docker与容器引擎CCE，则是对植物集群更精细化的运营</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/16/【Grow】没什么主题的抱怨/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杰瑞李">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/16/【Grow】没什么主题的抱怨/" itemprop="url">【Grow】没什么主题的抱怨</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-16T20:03:24+08:00">
                2019-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>校招入职3个月了，在云部门做PaaS平台相关的产品工作。感觉从第一个月的时候自己就不太喜欢这个方向吧，3个月以来主要精力放在了产品层面的页面逻辑设计上，其实和一般的C端产品设计是差不太多的，对PM的要求要多了一层对容器和云相关技术的理解，产品功能与底层技术实现是高耦合的，意味着要在理解集群、环境、容器、网络知识的前提下，去进行产品信息架构的规划与设计。一方面自己对偏底层的技术实在没有太大的兴趣，另一方面对产品设计不能快速得到用户反馈和数据验证倍感不适。</p>
<p>想想自己还是对策略设计的产品工作感兴趣罢，虽然同样逻辑复杂，但能够和业务联系更紧密，能够在诸多局限条件下利用数据驱动去求最优解的过程，更能感受到作为pm的成就感啊。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jerry Lee</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jerry Lee</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
